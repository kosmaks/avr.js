\newpage
\section{Реализация}

\subsection{Технологии и библиотеки}

Как говорилось ранее, проект реализован под веб-платформу. Для разработки используются следующие технологии:

\begin{itemize}
  \item HTML5 -- язык разметки, используемый для построения структуры и представления веб-страниц. 
    Это пятая версия языка, которая добавляет поддержку тэга \textless{}canvas\textgreater{}, 
    который позволяет скриптовому попиксельному отображению изображений через различные контексты. 
    На момент написания работы, доступно два основных контекста: 2d и webgl.

    2D был первым реализованным типом контекста. Он реализован как абстрактный автомат (схоже 
    с OpenGL) и может быть использован для высокопроизводительной визуализации двухмерных объектов, 
    таких как линии, прямоугольники, кривые, bitmap-изображения и т.д.

    Следующий тип контекста позволил разработчикам создавать высокопроизводительные 3D изображения 
    без использования сторонних плагинов и расширений. Это значит что пользователям не требуется 
    устанавливать дополнительное ПО (например, Adobe Flash Player или Java VM) для просмотра.

  \item Javascript -- динамичный язык программирования. Используется для взаимодействия с 
    пользователями, контроля браузером и асинхронной загрузки ресурсов.

  \item Coffeescript -- язык программирования, который транслируется в javascript. Добавляет 
    синтаксический сахар для повышения краткости и читаемости кода. Например, классы 
    (из объектно-ориентированного программирования), которые имеют четкую и понятную структуру.

  \item WebGL -- спецификация интерфейса для создания динамичных 2D и 3D сцен без использования 
    сторонних плагинов. Создан и поддерживается организацией Khronos Group, на данный момент, 
    разрабатывающей спецификацию OpenGL. WebGL служит связкой между высокоуровневым языком 
    JavaScript и низкоуровневыми операциями на графических процессорах.

  \item GLSL (OpenGL Shading Language) -- язык высокого уровня для программирования шейдеров. 
    Основным преимуществом GLSL является переносимость между платформами и ОС. Т.е. алгоритмы, 
    описанные в рамках данной работы, могут быть перенесены на другие платформы без изменения 
    кода программы.
\end{itemize}

Для упрощения разработки используется Zepto.js. Zepto.js -- библиотека для расширения функционала 
javascript. В частности реализует работу с AJAX запросами, которые используются для загрузки 
ресурсов. Является минималистичным аналогом jQuery, который также может являться альтернативой.

Основным преимуществом данного подхода к реализации является платформонезвисиммость и быстрота 
разработки.

\subsection{Общая архитектура}
\subsection{Реализация демонстрационного примера}
\subsubsection{Гидродинамика сглаженных частиц}

Гидродинамика сглаженных частиц (англ. Smoothed Particle Hydrodynamics, SPH) -- вычислительный 
метод, используемый для симуляции флюидов.

Флюид -- текучие вещества. К ним можно отнести:
\begin{itemize}
  \item жидкости. Примером жидкости может служить вода, масло, и т.д.;
  \item газы. Плотность данной среды меньше чем жидкостей. Пример: воздух;
  \item плазма;
\end{itemize}

Симуляция флюидов обычно описывается уравнениями Навье-Стокса.
Они являются одними из важнейших в гидродинамике и применяются в математическом
моделировании природных явлений и технических задач.

\begin{equation}
\label{eq:nve1}
  \rho[\frac{\delta{}v}{\delta{}t} + v \bullet \bigtriangledown{}v] = \rho{}g - \bigtriangledown{}p + \mu{}\bigtriangledown^2v
\end{equation}

\begin{equation}
\label{eq:massCont}
  \rho(\bigtriangledown\bullet{}v) = 0
\end{equation}

Двигаясь за счет гравитации $g$, давления $\bigtriangledown{}p$ и скорости $\mu\bigtriangledown^2v$ частицы жидкости движутся из зоны высокого давления в зону низкого.

Еще один параметр который влияет на поведение флюидов -- вязкость $\mu$.
Примером текучего вещества с низкой вязкостью может являться вода, воздух.
С высокой: мед, грязь. \\

В данной работе рассмотрен упрощенный случай: симуляция несжимаемого потока
Ньютоновских флюидов. Уравнение \eqref{eq:nve1} описывает состояние жидкости.

Составляющие уравнения:

\begin{itemize}
  \item $\rho$ -- плотность (скалярная величина);
  \item $p$ -- давление (скалярная величина);
  \item $g$ -- вектор гравитации;
  \item $v$ -- вектор скорости;
\end{itemize}

Давление $p$ может быть представлено как

\begin{equation}
\label{eq:pressure}
  p = k(\rho - \rho_0)
\end{equation}

, где $\rho_0$ -- плотность вне флюида. \\

Уравнение \eqref{eq:massCont} может быть выполнено при условии что масса частиц
постоянна и частицы ниоткуда не создаются и никуда не исчезают.

Конечный вид уравнения для каждой частицы принимает вид:

\begin{equation}
\label{eq:}
\frac{dv_i}{dt} = g - \frac{1}{\rho_i}\bigtriangledown{}p + \frac{\mu}{\rho_i}\bigtriangledown^2v
\end{equation}

Суть вычислительного метода гидродинамики сглаженных частиц состоит в аппроксимации величин
уравнений Навье-Стокса с использованием функции сглаживающего ядра.

\begin{equation}
\label{eq:mon1992}
A_i(r) = \int{}A(r')W(r - r', h)dr' \approx \sum_{b}A(r_b)W(r - r_b, h)
\end{equation}

И аппроксимация в условиях уравнений Навье-Стокса:

\begin{equation}
\label{eq:}
  \rho_i \approx \sum_{j}m_jW(r - r_j, h)
\end{equation}

\begin{equation}
\label{eq:}
\frac{\bigtriangledown{}p_i}{\rho_i} \approx \sum_{j}m_j(\frac{p_i}{\rho_i^2} + \frac{p_j}{\rho_j^2})\bigtriangledown{}W(r - r_j, h)
\end{equation}

\begin{equation}
\label{eq:}
\frac{\mu}{\rho_i}\bigtriangledown^2v_i \approx \frac{\mu}{\rho_i}\sum_{j}m_j(\frac{v_j - v_i}{\rho_j})\bigtriangledown^2W(r - r_j, h)
\end{equation}

, где $m$ -- масса, $r$ -- положение, $h$ -- радиус взаимодействия частиц. \\

Ограничения, которые накладываются на функции сглаживающего ядра:

\begin{itemize}
  \item $W = 0$ когда $||r - r_j|| > h$
  \item $W$ суммируется в $1$ по сфере радиуса $h$
\end{itemize}

В данной работе используются следующие ядра:

\begin{equation}
\label{eq:}
W(r - r_j, h) \equiv \frac{315}{64\pi{}h^9}(h^2-||r-r_j||^2)^3
\end{equation}

\begin{equation}
\label{eq:}
\bigtriangledown{}W(r - r_j, h) \equiv \frac{-45}{\pi{}h^6}(h - ||r - r_b||)^2\frac{r - r_j}{||r - r_j||}
\end{equation}

\begin{equation}
\label{eq:}
\bigtriangledown^2W(r - r_j, h) \equiv \frac{45}{\pi{}h^6}(h - ||r - r_j||)
\end{equation}

Простой подход к реализации -- полный перебор. Преимуществом данного подходя является быстрота
реализации. Однако сложность данного алгоритма $O(n^2)$, что означает что на достаточно большом
количестве частиц, он будет работать не эффективно.

Методы оптимизации полного перебора:

\begin{itemize}
  \item Ввиду того, что значение функции ядер на расстоянии превышающем $h$ равны 0 -- нет смысла
    просчитывать взаимодействие между всеми частицами. Для этого необходимо реализовать
    алгоритм поиска ближайших частиц.
  \item Практика показывает, что при симуляции не обязательно учитывать все частицы в радиусе, а
    ограничить их максимальное количество. Данный порог может быть использован в качестве
    параметра, задаваемого пользователем при симуляции.
\end{itemize}

Данный вычислительный метод весьма чувствителен к значениям. Поэтому вычисления составляющих
уравнения будут производиться в масштабе $\times0.004$. \\

Детализация алгоритма:

\begin{enumerate}
  \item задаются начальные положения и скорости частиц;
  \item рассчитываются ближайшие частицы с помощью сетки;
  \item вычисляется значение плотности $\rho$ для каждой из частиц;
  \item вычисляется значения градиентов давления $\bigtriangledown{}p$ и делятся на плотность;
  \item вычисляется значение скоростей, зависимых от вязкости $\frac{\mu}{\rho_i}\bigtriangledown^2v$ ;
  \item полученные значения складываются, добавляется значение вектора гравитации. Полученный
    результат прибавляется к старому значению скорости;
  \item на основе скоростей частиц меняется их положение;
  \item переход на шаг 3;
\end{enumerate}

Каждый шаг алгоритма можно представить в виде шейдерной программы. Информация о каждой из частиц 
заносится в соответствующий кадровый буфер. 

Потребуются следующие структуры данных:

\begin{itemize}
  \item 2 буфера для значений положений (текущее и будущее состояние);
  \item 2 буфера для значений скоростей (текущее и будущее состояние);
  \item 1 буфер для значений плотности;
  \item 2 буфера для значений градиентов давления (текущее и будущее состояние);
  \item 2 буфера для значений скоростей от вязкости (текущее и будущее состояние);
  \item 2 буфера для значений скоростей от вязкости (текущее и будущее состояние);
  \item 2 буфера для значений сетки (текущее и будущее состояние);
  \item 27 буферов для хранения информации об индексах каждой из соседних ячеек сетки;
\end{itemize}

\subsubsection{Поиск ближайших частиц}

В большинстве случаев частицы взаимодействуют друг с другом только если они находятся на 
заданном расстоянии. Т.е. определение соседних частиц ускоряет весь процесс симуляции.

Процесс определения соседних частиц занимает основное время всей симуляции. Существует
множество способов оптимизации. Ограничение объема, двоичное разбиение пространства, 
равномерная сетка, дискретизирующая пространство с целью улучшения производительности 
обнаружения соединений.

В рамках данной работы реализован подход основанный на составлении сетки, модифицированный
под вычисления на графическом процессоре. Задача данного алгоритма поиск частиц входящих в 
радус $h$ текущей.

Разделение пространства -- один из подходов ускорения вычислений SPH величин.
Поиск потенциальных соединений осуществляется внутри ячеек сетки и между непосредственными 
соседями. Отсюда улучшение скорости всей симуляции. Алгоритм, используемый в данной работе
основан на данном принципе. 

Вычисление на GPU накладывает некоторые ограничения. Возникает это из-за того, что 
фрагментные шейдеры, которые используются как основной вычислительный блок не могут
писать в память по заданному адресу. Это ограничение усложняет многие основные
алгоритмические операции (подсчет, сортировка, поиск максимума, минимума).  

Один из подходов обойти данное ограничение -- разбить все пространство на ячейки, т.е.
хранить информацию о каждом участке в одной большой сетке.  \\

Детализация алгоритма:

\begin{enumerate}
  \item Вычисление одномерной координаты в сетке для каждой из частиц. Это достигается за счет
    дискретизации положения частицы до размеров сетки $h$ и получении целочисленных координат
    $(i_x, i_y, i_z)$. Полученные координаты конвертируются в одномерную с помощью следующего
    уравнения:

    \begin{equation}
    \label{eq:}
      i_x + i_y \times G_w + i_z \times G_w \times G_h
    \end{equation}

    , где $G_w$ -- ширина сетки, $G_h$ -- высота сетки.

  \item Одномерный индекс каждой координату записывается в буфер с указателями (uv-координатами)
    на каждую из частиц. Затем выполняется сортировка частиц по данным индексам.

  \item С помощью бинарного поиска для каждой частицы находится начальный индекс в сортированном
    буфере и записывается в другой буфер, который будет использоваться для доступа к ближайшим
    частицам.

  \item Поиск потенциальных соседей осуществляется следованием от первого индекса в сортированном
    буфере до следующего значения. По указателям, хранящимся рядом с индексом можно получить 
    информацию до любой величины (плотность, давление, скорость, положение и т.д.)

  \item Операция повторяется 27 раз (в трехмерном случае) проверяя соседние ячейки сетки.
    Благодаря тому что информация о начале каждого индекса хранится в специальном буфере,
    поиск выполняется один раз.

\end{enumerate}

\subsubsection{Сортировка}

Ввиду ограничений, накладываемых архитектурой графических процессоров, традиционные алгоритмы
сортировки (быстрая сортировка, сортировка вставками и т.п.) будут не эффективны. А передача
данных на ЦП крайне нежелательна.

Существенной особенностью алгоритмов для графических процессоров является их многопроходность
и параллельный характер. Задача увеличения эффективности сводится в уменьшению количества
проходов, необходимых для сортировки.

В данной работе используется алгоритм битонической сортировки. Он фокусируется на конвертации
последовательности случайных чисел в битоническую последовательность: которая сначала
монотонно увеличивается, а затем монотонно возрастает.

Битоническая сортировка может быть смоделирована как тип сортирующей сети. Начальная
не сортированная последовательность проходит через конвейер, где набор компараторов 
меняет местами значения в порядке возрастания или убывания.

Алгоритм сортировки состоит из двух операций: разделения и слияния.

Операция разделения -- процедура, которая разделяет одну битоническую последовательность на
две более мелкие. Причем элементы первой меньше или равны элементам второй.

Операция слияния -- вариация предыдущей: две смежных битонических последовательности
сливаются в одну и сортируются по возрастанию. Следующие две по убыванию и т.д. 
Две последовательности становятся одной битонической. Процедура повторяется до тех пор пока 
все входы сети полностью не покрыты. 
