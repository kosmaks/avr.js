// Generated by LiveScript 1.2.0
(function(){
  (function(it){
    return window.onload = it;
  })(function(){
    var el, gl, idVertexShader, redVertexShader, createBuffer, createProgram, createFramebuffer, display, useProgram, useFramebuffer, useTexture, readPixels, clear, drawLoop, pass, size, sizeM, sizex, sizey, h, m, texVertex, helper, mainProg, pointsProg, fillProg, convertProg, bitonicHelper, bitonicSortProg, bitonicMergeProg, bitonicSort, backBuf, frontBuf;
    el = document.getElementById('display');
    gl = el.getContext('experimental-webgl');
    gl.viewportWidth = el.width;
    gl.viewportHeight = el.height;
    gl.getExtension('OES_texture_float');
    idVertexShader = 'attribute vec2 vertex;\nvoid main(void) { gl_Position = vec4(vertex, 0.0, 1.0); }';
    redVertexShader = 'void main(void) { gl_FragColor = vec4(1.0, 0.4, 0.1, 1.0); }';
    createBuffer = function(verts){
      var buffer;
      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
      buffer.length = verts.length;
      return buffer;
    };
    createProgram = function(arg$){
      var ref$, vertex, ref1$, fragment, die, createShader, program;
      ref$ = arg$ != null
        ? arg$
        : {}, vertex = (ref1$ = ref$.vertex) != null ? ref1$ : idVertexShader, fragment = (ref1$ = ref$.fragment) != null ? ref1$ : redVertexShader;
      die = function(str){
        if (str.length > 0) {
          throw new Error(str);
        }
      };
      createShader = function(type, src){
        var shader;
        shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        die(gl.getShaderInfoLog(shader));
        return shader;
      };
      program = gl.createProgram();
      if (vertex != null) {
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertex));
      }
      if (fragment != null) {
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragment));
      }
      gl.linkProgram(program);
      die(gl.getProgramInfoLog(program));
      return program;
    };
    createFramebuffer = function(arg$){
      var ref$, attach, ref1$, size, format, type, data, tex, fb;
      ref$ = arg$ != null
        ? arg$
        : {}, attach = (ref1$ = ref$.attach) != null
        ? ref1$
        : gl.COLOR_ATTACHMENT0, size = (ref1$ = ref$.size) != null
        ? ref1$
        : [128, 128], format = (ref1$ = ref$.format) != null
        ? ref1$
        : gl.RGB, type = (ref1$ = ref$.type) != null
        ? ref1$
        : gl.FLOAT, data = (ref1$ = ref$.data) != null ? ref1$ : null;
      tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, type, data);
      fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, attach, gl.TEXTURE_2D, tex, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      fb.texture = tex;
      fb.size = size;
      fb.attach = attach;
      return fb;
    };
    display = createBuffer([-1, -1, 1, -1, -1, 1, 1, 1]);
    useProgram = function(program, cb){
      var currProgram, uniform, funcs;
      currProgram = gl.getParameter(gl.CURRENT_PROGRAM);
      uniform = function(name){
        return gl.getUniformLocation(program, name);
      };
      gl.useProgram(program);
      funcs = {
        sendFloat: function(name, value){
          return gl.uniform1f(uniform(name), value);
        },
        sendInt: function(name, value){
          return gl.uniform1i(uniform(name), value);
        },
        sendFloat2: function(name, values){
          return gl.uniform2f(uniform(name), values[0], values[1]);
        },
        drawBuffer: function(buffer, arg$){
          var ref$, type, ref1$, attrib, vars, loc;
          ref$ = arg$ != null
            ? arg$
            : {}, type = (ref1$ = ref$.type) != null
            ? ref1$
            : gl.POINTS, attrib = (ref1$ = ref$.attrib) != null ? ref1$ : 'vertex', vars = (ref1$ = ref$.vars) != null ? ref1$ : 3;
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          loc = gl.getAttribLocation(program, attrib);
          gl.enableVertexAttribArray(loc);
          gl.vertexAttribPointer(loc, vars, gl.FLOAT, false, 0, 0);
          return gl.drawArrays(type, 0, buffer.length / vars);
        },
        drawDisplay: function(arg$){
          var attrib, ref$;
          attrib = (ref$ = (arg$ != null
            ? arg$
            : {}).attrib) != null ? ref$ : 'vertex';
          return funcs.drawBuffer(display, {
            type: gl.TRIANGLE_STRIP,
            attrib: attrib,
            vars: 2
          });
        }
      };
      cb(funcs);
      return gl.useProgram(currProgram);
    };
    useFramebuffer = function(fb, cb){
      var currFb;
      currFb = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      cb({
        viewport: function(){
          return gl.viewport(0, 0, fb.size[0], fb.size[1]);
        },
        clear: function(it){
          return clear(import$({
            viewport: fb.size
          }, it));
        }
      });
      return gl.bindFramebuffer(gl.FRAMEBUFFER, currFb);
    };
    useTexture = function(tex, id){
      id == null && (id = 0);
      gl.activeTexture(gl["TEXTURE" + id]);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      return id;
    };
    readPixels = function(fb){
      var pixels;
      pixels = new Uint8Array(4 * fb.size[0] * fb.size[1]);
      useFramebuffer(fb, function(){
        return gl.readPixels(0, 0, fb.size[0], fb.size[1], gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      });
      return pixels;
    };
    clear = function(arg$){
      var ref$, viewport, ref1$, color;
      ref$ = arg$ != null
        ? arg$
        : {}, viewport = (ref1$ = ref$.viewport) != null
        ? ref1$
        : [gl.viewportWidth, gl.viewportHeight], color = (ref1$ = ref$.color) != null
        ? ref1$
        : [0.1, 0.1, 0.1, 1.0];
      gl.viewport(0, 0, viewport[0], viewport[1]);
      gl.clearColor(color[0], color[1], color[2], color[3]);
      return gl.clear(gl.COLOR_BUFFER_BIT);
    };
    drawLoop = function(delay, cb){
      return setInterval(cb, delay);
    };
    pass = function(program, fb, args, cb){
      args == null && (args = {});
      return useFramebuffer(fb, function(buf){
        return useProgram(program, function(prog){
          var i, k, ref$, v;
          i = 0;
          for (k in ref$ = args) {
            v = ref$[k];
            prog.sendInt(k, useTexture(v, i));
            i += 1;
          }
          buf.clear();
          if (typeof cb === 'function') {
            cb({
              buf: buf,
              prog: prog
            });
          }
          return prog.drawDisplay();
        });
      });
    };
    size = [2048, 1];
    sizeM = size[0] * size[1];
    sizex = size[0] + ".0";
    sizey = size[1] + ".0";
    h = 0.0002;
    m = 1;
    texVertex = "attribute vec2 vertex;\nvarying vec2 index;\n\nvoid main() {\n  index.x = (vertex.x > 0.) ? 1. : 0.;\n  index.y = (vertex.y > 0.) ? 1. : 0.;\n  gl_Position = vec4(vertex, 0., 1.);\n}";
    helper = "precision mediump float;\n#define AT(arr, x, y) texture2D(arr, vec2(x / " + sizex + ", y / " + sizey + ")";
    mainProg = createProgram({
      vertex: texVertex,
      fragment: "precision mediump float;\nuniform sampler2D sampler;\nvarying vec2 index;\n\nvoid main() {\n  gl_FragColor = texture2D(sampler, index);\n  gl_FragColor.w = 1.;\n}"
    });
    pointsProg = createProgram({
      vertex: "attribute vec2 vertex;\n\nvoid main() {\n  gl_PointSize = 3.;\n  gl_Position = vec4((vertex / 127.5) - 1., 0., 1.);\n}",
      fragment: "void main() {\n  gl_FragColor = vec4(0.1, 0.4, 1., 1.);\n}"
    });
    fillProg = createProgram({
      vertex: texVertex,
      fragment: "precision mediump float;\nvarying vec2 index;\n\nvoid main() {\n  gl_FragColor = vec4(\n    index.x,\n    mod(10. * index.x, 3.) / 3.,\n    0.,\n    1.\n  );\n}"
    });
    convertProg = createProgram({
      vertex: texVertex,
      fragment: "" + helper + "\nvarying vec2 index;\nuniform sampler2D fill;\n\nvoid main() {\n  vec2 pos = texture2D(fill, index).xy;\n  gl_FragColor.x = pos.x + pos.y * " + sizex + ";\n  gl_FragColor.y = 0.;\n  gl_FragColor.z = 0.;\n  gl_FragColor.w = 1.;\n}"
    });
    bitonicHelper = "#define X_TO_TEX(val) (val / " + sizex + ")\n#define Y_TO_TEX(val) (val / " + sizey + ")\n#define X_TO_PIX(val) floor(val * " + sizex + ")\n#define Y_TO_PIX(val) floor(val * " + sizey + ")\n\n#define TO_PIX(vec) vec2(X_TO_PIX(vec.x), Y_TO_PIX(vec.y))\n#define TO_TEX(vec) vec2(X_TO_TEX(vec.x), Y_TO_TEX(vec.y))\n\nvec2 coordShift(float shift, vec2 src) {\n  vec2 index = TO_PIX(src);\n  float wide = index.x + shift;\n  float indexX = mod(wide, " + sizex + ");\n  float indexY = index.y + floor(wide / " + sizex + ");\n  if (indexY > " + sizey + ") indexY -= " + sizey + ";\n  else if (indexY < 0.) indexY += " + sizey + ";\n  return TO_TEX(vec2(indexX, indexY));\n}\n\n#define DIR_CMP(forward, a, b) (forward == (a < b) ? a : b)";
    bitonicSortProg = createProgram({
      vertex: texVertex,
      fragment: "" + helper + "\n" + bitonicHelper + "\n\nvarying vec2 index;\nuniform float spread;\nuniform sampler2D src;\nvec2 current = texture2D(src, index).xy;\n\nvoid main() {\n  bool even = mod(floor(" + sizex + " * index.x / spread), 2.) == 0.;\n  vec2 bCoord = coordShift((even ? 1. : -1.) * spread, index);\n\n  float a = current.y;\n  float b = texture2D(src, bCoord).y;\n\n  // fill result\n  gl_FragColor.x = current.x;\n  gl_FragColor.y = DIR_CMP(even, a, b);\n  gl_FragColor.z = 0.;\n  gl_FragColor.w = 1.;\n}"
    });
    bitonicMergeProg = createProgram({
      vertex: texVertex,
      fragment: "" + helper + "\n" + bitonicHelper + "\n\nvarying vec2 index;\nuniform sampler2D src;\nuniform float count;\nvec2 current = texture2D(src, index).xy;\n\nfloat blockSize = " + sizeM + ". / count;\n\nvoid main() {\n  vec2 native = TO_PIX(index);\n  float curr = native.x + native.y * " + sizex + ";\n  bool even = mod(floor(curr / (blockSize / 2.)), 2.) == 0.;\n\n  float shift = (blockSize - 1.) - (2. * mod(curr, blockSize));\n  vec2 bCoord = coordShift(shift, index);\n\n  float a = current.y;\n  float b = texture2D(src, bCoord).y;\n\n  // fill result\n  gl_FragColor.x = current.x;\n  gl_FragColor.y = DIR_CMP(even, a, b);\n  gl_FragColor.z = 0.;\n  gl_FragColor.w = 1.;\n}"
    });
    bitonicSort = function(backBuf, frontBuf){
      var b, merge, sort;
      b = [backBuf, frontBuf];
      merge = sizeM / 2;
      while (merge >= 1) {
        pass(bitonicMergeProg, b[1], {
          src: b[0].texture
        }, fn$);
        b = [b[1], b[0]];
        sort = sizeM / merge / 4;
        while (sort >= 1) {
          pass(bitonicSortProg, b[1], {
            src: b[0].texture
          }, fn1$);
          b = [b[1], b[0]];
          sort /= 2;
        }
        merge /= 2;
      }
      return b[0];
      function fn$(b){
        return b.prog.sendFloat('count', merge);
      }
      function fn1$(b){
        return b.prog.sendFloat('spread', sort);
      }
    };
    backBuf = createFramebuffer({
      size: size
    });
    frontBuf = createFramebuffer({
      size: size
    });
    return useProgram(mainProg, function(prog){
      var resBuf, toDebug, pixels;
      pass(fillProg, backBuf);
      resBuf = bitonicSort(backBuf, frontBuf);
      toDebug = resBuf;
      clear();
      useTexture(toDebug.texture);
      prog.drawDisplay();
      pixels = readPixels(toDebug);
      return useProgram(pointsProg, function(points){
        return points.drawBuffer(createBuffer(pixels), {
          vars: 4
        });
      });
    });
  });
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
