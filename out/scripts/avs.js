// Generated by LiveScript 1.2.0
(function(){
  var AVS;
  window.AVS = AVS = (function(){
    AVS.displayName = 'AVS';
    var el, gl, idVertexShader, redVertexShader, prototype = AVS.prototype, constructor = AVS;
    el = 0;
    gl = 0;
    idVertexShader = 'attribute vec2 vertex;\nvoid main(void) { gl_Position = vec4(vertex, 0.0, 1.0); }';
    redVertexShader = 'void main(void) { gl_FragColor = vec4(1.0, 0.4, 0.1, 1.0); }';
    function AVS(element){
      if (element != null) {
        el = element;
        gl = el.getContext('experimental-webgl');
        if (gl != null) {
          gl.viewportWidth = el.width;
          gl.viewportHeight = el.height;
          gl.getExtension('OES_texture_float');
        }
      }
    }
    prototype.ready = function(){
      return gl != null;
    };
    prototype.gl = function(){
      return gl;
    };
    prototype.createBuffer = function(verts){
      var buffer;
      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
      buffer.length = verts.length;
      return buffer;
    };
    prototype.createProgram = function(arg$){
      var ref$, vertex, ref1$, fragment, die, createShader, program;
      ref$ = arg$ != null
        ? arg$
        : {}, vertex = (ref1$ = ref$.vertex) != null ? ref1$ : idVertexShader, fragment = (ref1$ = ref$.fragment) != null ? ref1$ : redVertexShader;
      die = function(str){
        if (str.length > 0) {
          throw new Error(str);
        }
      };
      createShader = function(type, src){
        var shader;
        shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        die(gl.getShaderInfoLog(shader));
        return shader;
      };
      program = gl.createProgram();
      if (vertex != null) {
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertex));
      }
      if (fragment != null) {
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragment));
      }
      gl.linkProgram(program);
      die(gl.getProgramInfoLog(program));
      return program;
    };
    prototype.createFramebuffer = function(arg$){
      var ref$, attach, ref1$, size, format, type, data, tex, fb;
      ref$ = arg$ != null
        ? arg$
        : {}, attach = (ref1$ = ref$.attach) != null
        ? ref1$
        : gl.COLOR_ATTACHMENT0, size = (ref1$ = ref$.size) != null
        ? ref1$
        : [128, 128], format = (ref1$ = ref$.format) != null
        ? ref1$
        : gl.RGBA, type = (ref1$ = ref$.type) != null
        ? ref1$
        : gl.FLOAT, data = (ref1$ = ref$.data) != null ? ref1$ : null;
      tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, type, data);
      fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, attach, gl.TEXTURE_2D, tex, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      fb.texture = tex;
      fb.size = size;
      fb.attach = attach;
      return fb;
    };
    prototype.display = function(){
      var ref$;
      return (ref$ = this.displayBuf) != null
        ? ref$
        : this.displayBuf = this.createBuffer([-1, -1, 1, -1, -1, 1, 1, 1]);
    };
    prototype.useProgram = function(program, cb){
      var currProgram, uniform, funcs, this$ = this;
      currProgram = gl.getParameter(gl.CURRENT_PROGRAM);
      uniform = function(name){
        return gl.getUniformLocation(program, name);
      };
      gl.useProgram(program);
      funcs = {
        sendFloat: function(name, value){
          return gl.uniform1f(uniform(name), value);
        },
        sendInt: function(name, value){
          return gl.uniform1i(uniform(name), value);
        },
        sendFloat2: function(name, values){
          return gl.uniform2f(uniform(name), values[0], values[1]);
        },
        drawBuffer: function(buffer, arg$){
          var ref$, type, ref1$, attrib, vars, loc;
          ref$ = arg$ != null
            ? arg$
            : {}, type = (ref1$ = ref$.type) != null
            ? ref1$
            : gl.POINTS, attrib = (ref1$ = ref$.attrib) != null ? ref1$ : 'vertex', vars = (ref1$ = ref$.vars) != null ? ref1$ : 3;
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          loc = gl.getAttribLocation(program, attrib);
          gl.enableVertexAttribArray(loc);
          gl.vertexAttribPointer(loc, vars, gl.FLOAT, false, 0, 0);
          return gl.drawArrays(type, 0, buffer.length / vars);
        },
        drawDisplay: function(arg$){
          var attrib, ref$;
          attrib = (ref$ = (arg$ != null
            ? arg$
            : {}).attrib) != null ? ref$ : 'vertex';
          return funcs.drawBuffer(this$.display(), {
            type: gl.TRIANGLE_STRIP,
            attrib: attrib,
            vars: 2
          });
        }
      };
      cb(funcs);
      return gl.useProgram(currProgram);
    };
    prototype.useFramebuffer = function(fb, cb){
      var currFb, this$ = this;
      currFb = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      cb({
        viewport: function(){
          return gl.viewport(0, 0, fb.size[0], fb.size[1]);
        },
        clear: function(it){
          return this$.clear(import$({
            viewport: fb.size
          }, it));
        }
      });
      return gl.bindFramebuffer(gl.FRAMEBUFFER, currFb);
    };
    prototype.useTexture = function(tex, id){
      id == null && (id = 0);
      gl.activeTexture(gl["TEXTURE" + id]);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      return id;
    };
    prototype.readPixels = function(fb){
      var pixels;
      pixels = new Uint8Array(4 * fb.size[0] * fb.size[1]);
      this.useFramebuffer(fb, function(){
        return gl.readPixels(0, 0, fb.size[0], fb.size[1], gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      });
      return pixels;
    };
    prototype.clear = function(arg$){
      var ref$, viewport, ref1$, color;
      ref$ = arg$ != null
        ? arg$
        : {}, viewport = (ref1$ = ref$.viewport) != null
        ? ref1$
        : [gl.viewportWidth, gl.viewportHeight], color = (ref1$ = ref$.color) != null
        ? ref1$
        : [0.1, 0.1, 0.1, 1.0];
      gl.viewport(0, 0, viewport[0], viewport[1]);
      gl.clearColor(color[0], color[1], color[2], color[3]);
      return gl.clear(gl.COLOR_BUFFER_BIT);
    };
    prototype.drawLoop = function(delay, cb){
      var frames, start, fps;
      frames = 0;
      start = (new Date).getTime();
      fps = document.createElement('div');
      fps.setAttribute('style', 'position: fixed; top: 0; left: 0; padding: 5px; background: white; color: black; opacity: 0.5;');
      document.body.appendChild(fps);
      return setInterval(function(){
        var end;
        cb();
        frames += 1;
        end = (new Date).getTime();
        return fps.innerHTML = "FPS: " + Math.round(frames / ((end - start) / 1000));
      }, delay);
    };
    prototype.pass = function(program, fb, args, cb){
      var this$ = this;
      args == null && (args = {});
      return this.useFramebuffer(fb, function(buf){
        return this$.useProgram(program, function(prog){
          var i, k, ref$, v;
          i = 0;
          for (k in ref$ = args) {
            v = ref$[k];
            prog.sendInt(k, this$.useTexture(v, i));
            i += 1;
          }
          buf.clear();
          if (typeof cb === 'function') {
            cb({
              buf: buf,
              prog: prog
            });
          }
          return prog.drawDisplay();
        });
      });
    };
    prototype.prettyPrint = function(fb){
      var pixels, out, step, i$, ref$, len$, x;
      pixels = this.readPixels(fb);
      out = "-- Framebuffer: " + fb.size[0] + "x" + fb.size[1] + " --";
      step = 0;
      for (i$ = 0, len$ = (ref$ = (fn$())).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if ((x / 4) % fb.size[0] === 0) {
          console.log(out);
          out = "";
        }
        if (step === 0) {
          out += "[";
        }
        out += (pixels[x] / 255).toFixed(2);
        out += step === 3
          ? (step = 0, "] ")
          : (step += 1, ", ");
      }
      console.log("---");
      return pixels;
      function fn$(){
        var i$, to$, results$ = [];
        for (i$ = 0, to$ = pixels.length; i$ <= to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }
    };
    return AVS;
  }());
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
