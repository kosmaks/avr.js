// Generated by LiveScript 1.2.0
(function(){
  (function(it){
    return window.onload = it;
  })(function(){
    var el, gl, idVertexShader, redVertexShader, createBuffer, createProgram, createFramebuffer, display, useProgram, useFramebuffer, useTexture, readPixels, clear, drawLoop, size, sizex, sizey, h, m, texVertex, helper, mainProg, fillProg, fillBuf;
    el = document.getElementById('display');
    gl = el.getContext('experimental-webgl');
    gl.viewportWidth = el.width;
    gl.viewportHeight = el.height;
    gl.getExtension('OES_texture_float');
    idVertexShader = 'attribute vec2 vertex;\nvoid main(void) { gl_Position = vec4(vertex, 0.0, 1.0); }';
    redVertexShader = 'void main(void) { gl_FragColor = vec4(1.0, 0.4, 0.1, 1.0); }';
    createBuffer = function(verts){
      var buffer;
      buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
      buffer.length = verts.length;
      return buffer;
    };
    createProgram = function(arg$){
      var ref$, vertex, ref1$, fragment, die, createShader, program;
      ref$ = arg$ != null
        ? arg$
        : {}, vertex = (ref1$ = ref$.vertex) != null ? ref1$ : idVertexShader, fragment = (ref1$ = ref$.fragment) != null ? ref1$ : redVertexShader;
      die = function(str){
        if (str.length > 0) {
          throw new Error(str);
        }
      };
      createShader = function(type, src){
        var shader;
        shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        die(gl.getShaderInfoLog(shader));
        return shader;
      };
      program = gl.createProgram();
      if (vertex != null) {
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertex));
      }
      if (fragment != null) {
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragment));
      }
      gl.linkProgram(program);
      die(gl.getProgramInfoLog(program));
      return program;
    };
    createFramebuffer = function(arg$){
      var ref$, attach, ref1$, size, format, type, data, tex, fb;
      ref$ = arg$ != null
        ? arg$
        : {}, attach = (ref1$ = ref$.attach) != null
        ? ref1$
        : gl.COLOR_ATTACHMENT0, size = (ref1$ = ref$.size) != null
        ? ref1$
        : [128, 128], format = (ref1$ = ref$.format) != null
        ? ref1$
        : gl.RGB, type = (ref1$ = ref$.type) != null
        ? ref1$
        : gl.FLOAT, data = (ref1$ = ref$.data) != null ? ref1$ : null;
      tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, type, data);
      fb = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, attach, gl.TEXTURE_2D, tex, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      fb.texture = tex;
      fb.size = size;
      fb.attach = attach;
      return fb;
    };
    display = createBuffer([-1, -1, 1, -1, -1, 1, 1, 1]);
    useProgram = function(program, cb){
      var currProgram, uniform, funcs;
      currProgram = gl.getParameter(gl.CURRENT_PROGRAM);
      uniform = function(name){
        return gl.getUniformLocation(program, name);
      };
      gl.useProgram(program);
      funcs = {
        sendFloat: function(name, value){
          return gl.uniform1f(uniform(name), value);
        },
        sendInt: function(name, value){
          return gl.uniform1i(uniform(name), value);
        },
        sendFloat2: function(name, values){
          return gl.uniform2f(uniform(name), values[0], values[1]);
        },
        drawBuffer: function(buffer, arg$){
          var ref$, type, ref1$, attrib, vars, loc;
          ref$ = arg$ != null
            ? arg$
            : {}, type = (ref1$ = ref$.type) != null
            ? ref1$
            : gl.POINTS, attrib = (ref1$ = ref$.attrib) != null ? ref1$ : 'vertex', vars = (ref1$ = ref$.vars) != null ? ref1$ : 3;
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          loc = gl.getAttribLocation(program, attrib);
          gl.enableVertexAttribArray(loc);
          gl.vertexAttribPointer(loc, vars, gl.FLOAT, false, 0, 0);
          return gl.drawArrays(type, 0, buffer.length / vars);
        },
        drawDisplay: function(arg$){
          var attrib, ref$;
          attrib = (ref$ = (arg$ != null
            ? arg$
            : {}).attrib) != null ? ref$ : 'vertex';
          return funcs.drawBuffer(display, {
            type: gl.TRIANGLE_STRIP,
            attrib: attrib,
            vars: 2
          });
        }
      };
      cb(funcs);
      return gl.useProgram(currProgram);
    };
    useFramebuffer = function(fb, cb){
      var currFb;
      currFb = gl.getParameter(gl.FRAMEBUFFER_BINDING);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      cb({
        viewport: function(){
          return gl.viewport(0, 0, fb.size[0], fb.size[1]);
        },
        clear: function(it){
          return clear(import$({
            viewport: fb.size
          }, it));
        }
      });
      return gl.bindFramebuffer(gl.FRAMEBUFFER, currFb);
    };
    useTexture = function(tex, id){
      id == null && (id = 0);
      gl.activeTexture(gl["TEXTURE" + id]);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      return id;
    };
    readPixels = function(fb){
      var pixels;
      pixels = new Uint8Array(4 * fb.size[0] * fb.size[1]);
      useFramebuffer(fb, function(){
        return gl.readPixels(0, 0, fb.size[0], fb.size[1], gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      });
      return pixels;
    };
    clear = function(arg$){
      var ref$, viewport, ref1$, color;
      ref$ = arg$ != null
        ? arg$
        : {}, viewport = (ref1$ = ref$.viewport) != null
        ? ref1$
        : [gl.viewportWidth, gl.viewportHeight], color = (ref1$ = ref$.color) != null
        ? ref1$
        : [0.1, 0.1, 0.1, 1.0];
      gl.viewport(0, 0, viewport[0], viewport[1]);
      gl.clearColor(color[0], color[1], color[2], color[3]);
      return gl.clear(gl.COLOR_BUFFER_BIT);
    };
    drawLoop = function(delay, cb){
      return setInterval(cb, delay);
    };
    size = [8, 8];
    sizex = size[0] + ".0";
    sizey = size[1] + ".0";
    h = 0.0002;
    m = 1;
    texVertex = "attribute vec2 vertex;\nvarying vec2 index;\n\nvoid main() {\n  index.x = (vertex.x > 0.) ? 1. : 0.;\n  index.y = (vertex.y > 0.) ? 1. : 0.;\n  gl_Position = vec4(vertex, 0., 1.);\n}";
    helper = "precision mediump float;\nuniform sampler2D backbuffer;\nvarying vec2 index;\nvec4 current = texture2D(backbuffer, index);";
    mainProg = createProgram({
      vertex: texVertex,
      fragment: "precision mediump float;\nuniform sampler2D sampler;\nvarying vec2 index;\n\nvoid main() {\n  gl_FragColor = texture2D(sampler, index);\n  gl_FragColor.w = 1.;\n}"
    });
    fillProg = createProgram({
      vertex: texVertex,
      fragment: "precision mediump float;\nvarying vec2 index;\n\nvoid main() {\n  gl_FragColor = vec4(\n    (1. - index.x), \n    index.x * index.y, \n    (0.5 - index.y) + 0.5, \n    1.\n  );\n}"
    });
    fillBuf = createFramebuffer({
      size: size
    });
    return drawLoop(300, function(){
      var pass;
      pass = function(program, fb, args){
        args == null && (args = {});
        return useFramebuffer(fb, function(buf){
          return useProgram(program, function(prog){
            var i, k, ref$, v;
            i = 0;
            for (k in ref$ = args) {
              v = ref$[k];
              prog.sendInt(k, useTexture(k, i));
              i += 1;
            }
            buf.clear();
            return prog.drawDisplay();
          });
        });
      };
      return useProgram(mainProg, function(prog){
        clear();
        pass(fillProg, fillBuf);
        useFbTexture(fillBuf);
        return prog.drawDisplay();
      });
    });
  });
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
